{
    "version": "https://jsonfeed.org/version/1",
    "title": "jQueryZK Blog • All posts by \"类\" tag",
    "description": "过去无法挽回，未来可以改变",
    "home_page_url": "https://jqueryzk.gitee.io/zkblog",
    "items": [
        {
            "id": "https://jqueryzk.gitee.io/zkblog/2020/08/30/Java%E5%AD%A6%E4%B9%A0-Random%E7%B1%BB%E5%92%8CMath%E7%B1%BB/",
            "url": "https://jqueryzk.gitee.io/zkblog/2020/08/30/Java%E5%AD%A6%E4%B9%A0-Random%E7%B1%BB%E5%92%8CMath%E7%B1%BB/",
            "title": "Java学习-Random类和Math类",
            "date_published": "2020-08-30T12:42:34.844Z",
            "content_html": "<h1 id=\"random类\"><a class=\"markdownIt-Anchor\" href=\"#random类\">#</a> Random 类</h1>\n<h2 id=\"1-什么是random类\"><a class=\"markdownIt-Anchor\" href=\"#1-什么是random类\">#</a> 1 、什么是 Random 类</h2>\n<p>此类的实例用于生成伪随机数<br>\n Random 类中实现的随机算法是<strong>伪随机</strong>，也就是<strong>有规则</strong>的随机。在进行随机时，随机算法的起源数字称为<strong>种子数 (seed)</strong>，在种子数的基础上进行一定的变换，从而产生需要的随机数字。相同种子数的 Random 对象，<strong>相同次数生成的随机数字是完全相同的</strong>。也就是说，<font color=red><strong>两个种子数相同的 Random 对象，第一次生成的随机数字完全相同，第 N 次生成的随机数字也完全相同</strong></font>。这点在生成多个随机数字时需要特别注意。</p>\n<p>（注意：<strong>种子数只是随机算法的起源数字，和生成的随机数字的区间无关</strong>）</p>\n<h2 id=\"2-random类的使用步骤\"><a class=\"markdownIt-Anchor\" href=\"#2-random类的使用步骤\">#</a> 2、Random 类的使用步骤</h2>\n<p><strong>查看类：</strong></p>\n<ul>\n<li><code>java.util.Random</code>  ：该类需要 import 导入使后使用。</li>\n</ul>\n<p><strong>查看构造方法</strong></p>\n<ul>\n<li><code>public Random()</code>  ：创建一个新的随机数生成器。</li>\n<li><code>public Random(long seed)</code> ：该构造方法可以通过制定一个种子数进行创建。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Random r = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">Random r1 = <span class=\"keyword\">new</span> Random(<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n<p><strong>查看成员方法</strong><br>\n Random 类中的方法比较简单，每个方法的功能也很容易理解。需要说明的是，Random 类中各方法生成的随机数字都是均匀分布的，也就是说区间内部的数字生成的几率是均等的</p>\n<ul>\n<li>\n<p><code>public int nextInt()</code>  ：返回一个伪随机数，范围在 0 （包括）和 指定值 n （不包括）之间的 int 值。</p>\n</li>\n<li>\n<p><code>public boolean nextBoolean()</code> ：该方法的作用是生成一个随机的 boolean 值，生成 true 和 false 的值几率相等，也就是都是 50% 的几率。</p>\n</li>\n<li>\n<p><code>public double nextDouble()</code> ：该方法的作用是生成一个随机的 double 值，数值介于 [0,1.0) 之间。</p>\n</li>\n<li>\n<p><code>public int nextInt()</code> ：该方法的作用是生成一个随机的 int 值，该值介于 int 的区间，也就是 - 2^31 到 2^31-1 之间。</p>\n</li>\n<li>\n<p><code>public int nextInt(int n)</code> ：生成指定区间的 int 值，该方法的作用是生成一个随机的 int 值，该值介于 [0,n) 的区间，也就是<strong> 0 到 n 之间的随机 int 值，包含 0 而不包含 n</strong>。</p>\n</li>\n<li>\n<p><code>public void setSeed(long seed)</code> ：该方法的作用是重新设置 Random 对象中的种子数。设置完种子数以后的 Random 对象和相同种子数使用 new 关键字创建出的 Random 对象相同。</p>\n</li>\n</ul>\n<h2 id=\"3-具体应用\"><a class=\"markdownIt-Anchor\" href=\"#3-具体应用\">#</a> 3、具体应用</h2>\n<p>使用 Random 类，完成生成 3 个 10 以内的随机整数的操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Random; </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">test</span> </span>&#123; </span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123; </span><br><span class=\"line\">\t\t<span class=\"comment\">//2. 创建键盘录入数据的对象 </span></span><br><span class=\"line\">\t\tRandom r = <span class=\"keyword\">new</span> Random(); </span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++)&#123; </span><br><span class=\"line\">\t\t\t<span class=\"comment\">//3. 随机生成一个数据</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> number = r.nextInt(<span class=\"number\">10</span>); </span><br><span class=\"line\">\t\t\t<span class=\"comment\">//4. 输出数据 </span></span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">&quot;number:&quot;</span>+ number); </span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; \t\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>获取 1-n 之间的随机数，<strong>包含 n</strong>，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1. 导包 </span></span><br><span class=\"line\"> <span class=\"keyword\">import</span> java.util.Random; </span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">test</span> </span>&#123; </span><br><span class=\"line\">\t <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t <span class=\"keyword\">int</span> n = <span class=\"number\">50</span>; </span><br><span class=\"line\">\t\t <span class=\"comment\">// 创建对象 </span></span><br><span class=\"line\">\t\t Random r = <span class=\"keyword\">new</span> Random(); </span><br><span class=\"line\">\t\t <span class=\"comment\">// 获取随机数 </span></span><br><span class=\"line\">\t\t <span class=\"keyword\">int</span> number = r.nextInt(n) + <span class=\"number\">1</span>; </span><br><span class=\"line\">\t\t <span class=\"comment\">// 输出随机数 </span></span><br><span class=\"line\">\t\t System.out.println(<span class=\"string\">&quot;number:&quot;</span> + number); </span><br><span class=\"line\">\t\t &#125; </span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>猜数字游戏：</strong> 游戏开始时，会随机生成一个 1-100 之间的整数 number 。玩家猜测一个数字 guessNumber ，会与 number 作比 较，系统提示大了或者小了，直到玩家猜中，游戏结束。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Random;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner; </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">test</span> </span></span><br><span class=\"line\"><span class=\"class\"></span>&#123; </span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 系统产生一个随机数1‐100之间的。 </span></span><br><span class=\"line\">\t\tRandom r = <span class=\"keyword\">new</span> Random(); </span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> number = r.nextInt(<span class=\"number\">100</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123; </span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 键盘录入我们要猜的数据 </span></span><br><span class=\"line\">\t\t\tScanner sc = <span class=\"keyword\">new</span> Scanner(System.in); </span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">&quot;请输入你要猜的数字(1‐100)：&quot;</span>); </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> guessNumber = sc.nextInt(); </span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 比较这两个数据(用if语句) </span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (guessNumber &gt; number) </span><br><span class=\"line\">\t\t\t&#123; </span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;你猜的数据&quot;</span> + guessNumber + <span class=\"string\">&quot;大了&quot;</span>); </span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (guessNumber &lt; number) </span><br><span class=\"line\">\t\t\t&#123; System.out.println(<span class=\"string\">&quot;你猜的数据&quot;</span> + guessNumber + <span class=\"string\">&quot;小了&quot;</span>); </span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> </span><br><span class=\"line\">\t\t\t&#123; </span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;恭喜你,猜中了&quot;</span>); </span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>; </span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"math类\"><a class=\"markdownIt-Anchor\" href=\"#math类\">#</a> Math 类</h1>\n<h2 id=\"1-概述\"><a class=\"markdownIt-Anchor\" href=\"#1-概述\">#</a> 1、概述</h2>\n<p><code>java.lang.Math</code>  类包含用于<strong>执行基本数学运算</strong>的方法，如初等指数、对数、平方根和三角函数。类似这样的工具 类，其<strong>所有方法均为静态方法</strong>，并且<strong>不会创建对象</strong>，调用起来非常简单。</p>\n<h2 id=\"2-常用运算方法\"><a class=\"markdownIt-Anchor\" href=\"#2-常用运算方法\">#</a> 2、常用运算方法</h2>\n<ul>\n<li><code>Math.sqrt()</code> ：计算平方根</li>\n<li><code>Math.cbrt()</code> ：计算立方根</li>\n<li><code>Math.hypot(x,y)</code> ：计算 (x 的平方 + y 的平方)<strong> 的平方根</strong></li>\n<li><code>Math.pow(a,b)</code> ：计算 a 的 b 次方</li>\n<li><code>Math.exp(x)</code> ：计算 e^x 的值</li>\n<li><code>Math.max()</code> ：计算最大值 Math.min ();// 计算最小值</li>\n<li><code>Math.abs()</code> ：返回 double 值的绝对值。</li>\n<li><code>Math.ceil()</code> ：天花板的意思，返回大于等于参数的最小的整数</li>\n<li><code>Math.floor()</code> ：地板的意思，返回小于等于参数最大的整数</li>\n<li><code>Math.random()</code> ： 取得一个大于或者等于 0.0 小于不等于 1.0 的随机数 [0,1)</li>\n<li><code>Math.rint()</code> ： 四舍五入 返回 double 值</li>\n<li><code>Math.round()</code> ： 四舍五入 float 时返回 int 值，double 时返回 long 值</li>\n<li><code>Math.nextUp(a)</code> ： 返回比 a 大一点点的浮点数</li>\n<li><code>Math.nextDown(a)</code> ： 返回比 a 小一点点的浮点数</li>\n<li><code>Math.nextAfter(a,b)</code> ：返回 (a,b) 或 (b,a) 间与 a 相邻的浮点数 b 可以比 a 小</li>\n</ul>\n",
            "tags": [
                "java",
                "类",
                "Random类",
                "Math类"
            ]
        },
        {
            "id": "https://jqueryzk.gitee.io/zkblog/2020/08/25/Java%E5%AD%A6%E4%B9%A0-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/",
            "url": "https://jqueryzk.gitee.io/zkblog/2020/08/25/Java%E5%AD%A6%E4%B9%A0-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/",
            "title": "Java学习-访问权限控制",
            "date_published": "2020-08-25T13:03:42.975Z",
            "content_html": "<h1 id=\"1-为什么要有访问权限控制\"><a class=\"markdownIt-Anchor\" href=\"#1-为什么要有访问权限控制\">#</a> 1、为什么要有访问权限控制？</h1>\n<p><strong>访问控制 (或隐藏具体实现) 与 “最初的实现并不恰当” 有关。</strong><br>\n所有优秀的作者，包括那些编写软件的程序员，都清楚其著作的某些部分直至重新创作的时候才变得完美，有时甚至要反复重写多次。如果你把一个代码段放到了某个位置，等过一会儿回头再看时，有可能会发现有更好的方式去实现相同的功能。这正是重构的原动力之一，重构即重写代码，以使得它更可读、更易理解，并因此而更具可维护性。但是，在这种修改和完善代码的愿望之下，也存在着巨大的压力。通常总是会有一些消费者 (客户端程序员) 需要你的代码在某些方面保持不变。因此你想改变代码，而他们却想让代码保持不变。由此而产生了在面向对象设计中需要考虑的一一个基本问题:“如何把变动的事物与保持不变的事物区分开来”。<br>\n这对<strong>类库 (library)</strong> 而言尤为重要。该类库的消费者必须依赖他所使用的那部分类库，并且能够知道如果类库出现了新版本，他们并不需要改写代码。从另一个方面来说，类库的开发者必须有权限进行修改和改进，并确保客户代码不会因为这些改动而受到影响。 这一目标可以通过约定来达到。例如，类库开发者必须同意在改动类库中的类时不得删除任何现有方法，因为那样会破坏客户端程序员的代码。但是，与之相反的情况会更加棘手。在有域 (即数据成员) 存在的情况下，类库开发者要怎样才能知道究竟都有哪些域已经被客户端程序员所调用了呢？这对于方法仅为类的实现的一部分，因此并不想让客户端程序员直接使用的情况来说同样如此。如果程序开发者想要移除旧的实现而要添加新的实现时，结果将会怎样呢？改动任何一个成员都有可能破坏客户端程序员的代码。于是类库开发者会手脚被缚，无法对任何事物进行改动。<br>\n为了解决这一问题，Java 提供了<strong>访问权限修饰词</strong>，以供类库开发人员向客户端程序员指明<br>\n哪些是可用的，哪些是不可用的。访向权限控制的等级，从最大权限到最小权限依次为:</p>\n<p><strong>public、protected、包访问权限 (没有关键词称为 &quot;缺省&quot;) 和 private</strong></p>\n<p>构件类库的概念以及对于谁有权取用该类库构件的控制问题都还是不完善的。其中仍旧存在着如何将构件捆绑到一个内聚的类库单元中的问题。对于这一点，Java 用<strong>关键字 package</strong> 加以控制，而访问权限修饰词会因类是存在于一个相同的包，还是存在于一个单独的包而受到影响。</p>\n<h1 id=\"2-包库单元\"><a class=\"markdownIt-Anchor\" href=\"#2-包库单元\">#</a> 2、包：库单元</h1>\n<p><strong>包内包含有一组类，它们在单一的名字空间之下被组织到一起。</strong></p>\n<pre><code>  例如，在Java的标准发布中有一个工具库，它被组织在java.util名字空间下。java.util中有一个叫做ArrayList的类，使用ArrayList的一种方式是用其全名java.util.ArrayList来指定。\n</code></pre>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">F</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        java.util.ArrayList list = <span class=\"keyword\">new</span> java.util.ArrayList();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就使得程序变得很冗长，因此可以转而用 import 关键字，如果想要导入单个的类，可以在 import 语句中命名该类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">F</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        ArrayList list = <span class=\"keyword\">new</span> java.util.ArrayList();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，就可以不用限定地使用 ArrayList 了。但是，这样做 java.util 中的其他类仍旧是都不可以使用的。要想导入其中的所有类，只需要使用 &quot;*&quot;</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*</span><br></pre></td></tr></table></figure>\n<p><strong>Java 常用的类库：</strong></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200808223508652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3OTE3OA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>\n<strong>注意：</strong><br>\n当编写一个 <strong>.Java</strong> 源代码文件时，此文件通常被称为<strong>编译单元</strong> (有时也被称为转译单元)。每个编译单元都必须有一个后缀名.java, 而在编译单元内则可以有一个 public 类，<strong>该类的名称必须与文件的名称相同</strong> (包括大小写，但不包括文件的后缀名.java)。<strong>每个编译单元只能有一一个 public 类，否则编译器就不会接受</strong>。如果在该编译单元之中还有额外的类的话，那么在包之外<br>\n的世界是无法看见这些类的，这是因为它们不是 public 类，而且它们主要用来为主 publice 类提供<br>\n支持。</p>\n<p>比如在 test 包下的 test.java 文件（编译单元）里面只能有一个和文件名称相同的 public 类也就是里面的 test 类 Person 类就不能加 public 限定符了。<br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200808222558691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3OTE3OA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>\n同一个 test 包名下的类 test02 可以调用 Person 类<br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200808222645339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3OTE3OA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>\n在另一个 test03 包名下的类 test03 就不能调用 Person 类了即使导入了包也不能，因为它不是 public 类型的<br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200808222651248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3OTE3OA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"3-java访问权限修饰词\"><a class=\"markdownIt-Anchor\" href=\"#3-java访问权限修饰词\">#</a> 3、Java 访问权限修饰词</h1>\n<ul>\n<li>\n<p>public：接口访问权限（无论是谁，无论在哪都可以访问）<br>\n使用关键字 public，就意味着 public 之后紧跟着的成员声明自己对每个人都是有用的，尤其是使用类库的客户程序员更是如此。</p>\n</li>\n<li>\n<p>protected：继承访问权限（子类可以访问父类的 public 成员和 protected 成员，但不可以访问父类的 private 成员）</p>\n</li>\n<li>\n<p>（缺省）：包访问权限（类内部和同一个包里面的类可以访问（缺省）成员）<br>\n因为（缺省）没有修饰词，形式如 int age ，也就是前面没有任何修饰词</p>\n</li>\n<li>\n<p>private: 你无法访问（除了包含该类成员的类之外，其他任何类都无法访问这个成员）</p>\n</li>\n</ul>\n<p>为了方便理解和比较准备了以下两张图片<br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200808223740311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3OTE3OA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200808223806321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3OTE3OA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n",
            "tags": [
                "java",
                "面向对象",
                "类",
                "访问权限"
            ]
        },
        {
            "id": "https://jqueryzk.gitee.io/zkblog/2020/08/21/Java%E5%AD%A6%E4%B9%A0-%E7%B1%BB%E7%9A%84%E9%9A%90%E8%97%8F%E6%9C%BA%E5%88%B6(%E5%B0%81%E8%A3%85%E6%80%A7)/",
            "url": "https://jqueryzk.gitee.io/zkblog/2020/08/21/Java%E5%AD%A6%E4%B9%A0-%E7%B1%BB%E7%9A%84%E9%9A%90%E8%97%8F%E6%9C%BA%E5%88%B6(%E5%B0%81%E8%A3%85%E6%80%A7)/",
            "title": "Java学习-类的隐藏机制（封装性）",
            "date_published": "2020-08-21T09:53:22.569Z",
            "content_html": "<h1 id=\"1-封装的含义\"><a class=\"markdownIt-Anchor\" href=\"#1-封装的含义\">#</a> 1、封装的含义</h1>\n<p><strong>封装</strong>（encapsulation）是面向对象的三要素之一（其它两个是<strong>继承</strong>和<strong>多态</strong>），它有两成含义：<br>\n1、将数据（属性）和函数（行为）放在一个独立的类中，使类成为一个独立的单元。<br>\n2、通过访问限定符（private 等）实现对<strong>信息的隐藏或公开</strong>，隐藏类的内部实现。而留下一些接口（public 的成员函数）与外界进行信息交换（外界要想访问某个成员只能通过接口实现）当类的设计者改变了类的内部实现时，但只要接口不变，对于类的使用者而言，没有任何影响。这就是所谓的 “<strong>接口和实现的分离</strong>”<br>\n<strong> 那么什么是封装？</strong> 简单地说，封装就是将数据和函数放在一起，将不想让外界看到的内容（通常是数据）声明为 private 的，不允许外界存取。外界要想访问的话，就只能通过类留给外部的接口。<br>\n<strong>为了更好的理解为什么要对对象进行封装，下面举个例子进行说明</strong><br>\n先写两个类  ：</p>\n<ul>\n<li>Person 类</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package day01</span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">\tpublic int age;</span><br><span class=\"line\">\tpublic <span class=\"keyword\">void</span> printAge()</span><br><span class=\"line\">\t&#123; </span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;年龄是：&quot;</span>+age);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Test 测试类</li>\n</ul>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package day01</span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span></span>&#123;</span><br><span class=\"line\">\t public <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(<span class=\"built_in\">String</span>[] args)</span><br><span class=\"line\">\t &#123;</span><br><span class=\"line\">\t \tPerson p = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">\t \tp.age = <span class=\"number\">-100</span>;</span><br><span class=\"line\">\t \tp.printAge();</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行后打印结果为：年龄是：-100<br>\n<strong> 分析一下代码：</strong><br>\n程序是没问题的也能正常运行，但是年龄为 - 100 显然不符合正常逻辑。从代码可以看出在 new 完一个 person 对象后用户可以对它的 age 属性随便赋值。像这种情况是把类的属性开放出来，让调用者随意使用，这样就会出现问题，它们很容易被一些粗心的或不知情的客户端程序员所毁坏。<br>\n所以我们需要对这样不能让调用者随意使用的属性做封装和隐藏以减少程序的 bug。这意味着类的创建者可以任意修改被隐藏的部分，而不用担心对其他调用者造成影响。<br>\n代码修改后如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package day01</span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">\tprivate int age;</span><br><span class=\"line\">\tpublic <span class=\"keyword\">void</span> setAge(int a)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a &lt;=<span class=\"number\">150</span> &amp;&amp; a&gt;=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">this</span>.age = a;\t</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">&quot;输入的年龄：&quot;</span>+a+<span class=\"string\">&quot;不在0到150之间&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic int getAge()</span><br><span class=\"line\">\t&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.age;&#125;</span><br><span class=\"line\">\tpublic <span class=\"keyword\">void</span> showAge()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;年龄是：&quot;</span>+<span class=\"built_in\">this</span>.getAge());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package day01</span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span></span>&#123;</span><br><span class=\"line\">\t public <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(<span class=\"built_in\">String</span>[] args)</span><br><span class=\"line\">\t &#123;</span><br><span class=\"line\">\t \tPerson p1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">\t \tPerson p2 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">\t \tp1.setAge(<span class=\"number\">55</span>);</span><br><span class=\"line\">\t \tp1.showAge();</span><br><span class=\"line\">\t \tp2.setAge(<span class=\"number\">60</span>);</span><br><span class=\"line\">\t \tp2.showAge();</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到修改过后的对象不能直接通过 p.age 进行赋值操作，因为此时的 age 属性已经是被 private 限制，只能由类内部的成员函数调用并进行传参。</p>\n<h1 id=\"2-类的setxxx-和-getxxx\"><a class=\"markdownIt-Anchor\" href=\"#2-类的setxxx-和-getxxx\">#</a> 2、类的 setXXX 和 getXXX</h1>\n<p>封装的一个原则是：“信息的最小化公开”, 所以在理想状态下，通常将所有的数据都声明为 private（因为随便对类的内部数据进行更改是很危险的），如果想改变和得到某个数据的话，那么使用相应的接口进行访问</p>\n<ul>\n<li>通常设置数据的接口命名为 setXXX（如 public void setAge () ）</li>\n<li>将得到数据的接口命名为 getXXX（如 public int getAge () ）<br>\n<strong>? 考虑这样两个问题：</strong><br>\n<strong>问题一：</strong> 使用 Person 类来定义的两个对象 p1 和 p2, 那么 p1 和 p2 两个对象在内存中的存储状态是怎么样的呢？即数据成员和成员函数是否都存放在对象中呢？<br>\n<strong>问题二：</strong> p1 和 p2 调用相同的成员函数，为什么显示结果不一样？它们调用的是同一段代码吗？<br>\n其实对象空间中仅存储数据成员，而类的成员函数代码不会存储在对象中，用一个类的不同的对象调用成员函数时，调用的是同一段函数代码。<br>\n<strong>成员函数和普通函数的区别：</strong><br>\n在编译器的角度来看，成员函数和普通函数是没有本质区别的，成员函数只不过是为了封装的需要，而在形式上放在类中。最主要的区别是：<br>\n<em>成员函数暗自具备了一个从编译器传过来的指向类对象的 this（当前对象的引用），通过它成员函数就可以操作当前对象的数据成员。</em></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person p1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">Person p2 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">p1.setAge(<span class=\"number\">55</span>);<span class=\"comment\">//在这里this指向p1</span></span><br><span class=\"line\">p2.setAge(<span class=\"number\">60</span>);<span class=\"comment\">//在这里this指向p2</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"3-this关键字\"><a class=\"markdownIt-Anchor\" href=\"#3-this关键字\">#</a> 3、this 关键字</h1>\n<ul>\n<li>在类的方法定义中使用的 this 关键字表示使用该方法对象的引用。</li>\n<li>当必须指出当前使用方法对象是谁时要使用 this</li>\n<li>this 可以看作是一个变量，它的值是当前对象的引用</li>\n<li>当处理方法中成员变量和局部变量重名时要用 this</li>\n</ul>\n<h1 id=\"4-总结\"><a class=\"markdownIt-Anchor\" href=\"#4-总结\">#</a> 4、总结</h1>\n<p>java 中类的封装和隐藏就是：<br>\n通过将类的成员数据声明为私有的（private），再提供公共的（public）方法：getXXX () 和 setXXX () 实现对该属性的操作。以实现以下目的。</p>\n<ul>\n<li>隐藏一个类中不需要对外提供的实现细节</li>\n<li>使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作；</li>\n<li>便于修改，增强代码的可维护性</li>\n</ul>\n",
            "tags": [
                "java",
                "面向对象",
                "类"
            ]
        }
    ]
}