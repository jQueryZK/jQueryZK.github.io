<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://yoursite.com</id>
    <title>jQueryZK Blog • Posts by &#34;类&#34; tag</title>
    <link href="http://yoursite.com" />
    <updated>2020-08-25T13:03:42.975Z</updated>
    <category term="java" />
    <category term="类" />
    <category term="面向对象" />
    <category term="栈" />
    <category term="数据结构" />
    <category term="逆波兰表达式" />
    <category term="算法" />
    <category term="环形链表" />
    <category term="约瑟夫" />
    <category term="设计模式" />
    <category term="七大原则" />
    <category term="计算机网络" />
    <category term="网络体系" />
    <category term="JavaWeb" />
    <category term="JSP" />
    <category term="JavaBean" />
    <category term="python" />
    <category term="网络爬虫" />
    <category term="数据可视化" />
    <category term="pyecharts" />
    <category term="sparsearray" />
    <category term="数组" />
    <category term="稀疏数组" />
    <category term="队列" />
    <category term="循环队列" />
    <category term="单链表" />
    <category term="学生成绩管理系统" />
    <category term="面试题" />
    <category term="多态性" />
    <category term="重写" />
    <category term="重载" />
    <category term="访问权限" />
    <category term="递归" />
    <category term="迷宫回溯" />
    <category term="继承" />
    <category term="super关键字" />
    <category term="回溯" />
    <category term="八皇后" />
    <category term="Object类" />
    <entry>
        <id>http://yoursite.com/2020/08/25/Java%E5%AD%A6%E4%B9%A0-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</id>
        <title>Java学习-访问权限控制</title>
        <link rel="alternate" href="http://yoursite.com/2020/08/25/Java%E5%AD%A6%E4%B9%A0-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
        <content type="html">&lt;h1 id=&#34;1-为什么要有访问权限控制&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#1-为什么要有访问权限控制&#34;&gt;#&lt;/a&gt; 1、为什么要有访问权限控制？&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;访问控制 (或隐藏具体实现) 与 “最初的实现并不恰当” 有关。&lt;/strong&gt;&lt;br&gt;
所有优秀的作者，包括那些编写软件的程序员，都清楚其著作的某些部分直至重新创作的时候才变得完美，有时甚至要反复重写多次。如果你把一个代码段放到了某个位置，等过一会儿回头再看时，有可能会发现有更好的方式去实现相同的功能。这正是重构的原动力之一，重构即重写代码，以使得它更可读、更易理解，并因此而更具可维护性。但是，在这种修改和完善代码的愿望之下，也存在着巨大的压力。通常总是会有一些消费者 (客户端程序员) 需要你的代码在某些方面保持不变。因此你想改变代码，而他们却想让代码保持不变。由此而产生了在面向对象设计中需要考虑的一一个基本问题:“如何把变动的事物与保持不变的事物区分开来”。&lt;br&gt;
这对&lt;strong&gt;类库 (library)&lt;/strong&gt; 而言尤为重要。该类库的消费者必须依赖他所使用的那部分类库，并且能够知道如果类库出现了新版本，他们并不需要改写代码。从另一个方面来说，类库的开发者必须有权限进行修改和改进，并确保客户代码不会因为这些改动而受到影响。 这一目标可以通过约定来达到。例如，类库开发者必须同意在改动类库中的类时不得删除任何现有方法，因为那样会破坏客户端程序员的代码。但是，与之相反的情况会更加棘手。在有域 (即数据成员) 存在的情况下，类库开发者要怎样才能知道究竟都有哪些域已经被客户端程序员所调用了呢？这对于方法仅为类的实现的一部分，因此并不想让客户端程序员直接使用的情况来说同样如此。如果程序开发者想要移除旧的实现而要添加新的实现时，结果将会怎样呢？改动任何一个成员都有可能破坏客户端程序员的代码。于是类库开发者会手脚被缚，无法对任何事物进行改动。&lt;br&gt;
为了解决这一问题，Java 提供了&lt;strong&gt;访问权限修饰词&lt;/strong&gt;，以供类库开发人员向客户端程序员指明&lt;br&gt;
哪些是可用的，哪些是不可用的。访向权限控制的等级，从最大权限到最小权限依次为:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public、protected、包访问权限 (没有关键词称为 &amp;quot;缺省&amp;quot;) 和 private&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;构件类库的概念以及对于谁有权取用该类库构件的控制问题都还是不完善的。其中仍旧存在着如何将构件捆绑到一个内聚的类库单元中的问题。对于这一点，Java 用&lt;strong&gt;关键字 package&lt;/strong&gt; 加以控制，而访问权限修饰词会因类是存在于一个相同的包，还是存在于一个单独的包而受到影响。&lt;/p&gt;
&lt;h1 id=&#34;2-包库单元&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2-包库单元&#34;&gt;#&lt;/a&gt; 2、包：库单元&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;包内包含有一组类，它们在单一的名字空间之下被组织到一起。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  例如，在Java的标准发布中有一个工具库，它被组织在java.util名字空间下。java.util中有一个叫做ArrayList的类，使用ArrayList的一种方式是用其全名java.util.ArrayList来指定。
&lt;/code&gt;&lt;/pre&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;F&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;    &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        java.util.ArrayList list = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; java.util.ArrayList();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样就使得程序变得很冗长，因此可以转而用 import 关键字，如果想要导入单个的类，可以在 import 语句中命名该类：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;import&lt;/span&gt; java.util.ArrayList;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;F&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;    &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        ArrayList list = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; java.util.ArrayList();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在，就可以不用限定地使用 ArrayList 了。但是，这样做 java.util 中的其他类仍旧是都不可以使用的。要想导入其中的所有类，只需要使用 &amp;quot;*&amp;quot;&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;import&lt;/span&gt; java.util.*&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Java 常用的类库：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src= &#34;/img/loading.gif&#34; data-lazy-src=&#34;https://img-blog.csdnimg.cn/20200808223508652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3OTE3OA==,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;br&gt;
&lt;strong&gt;注意：&lt;/strong&gt;&lt;br&gt;
当编写一个 &lt;strong&gt;.Java&lt;/strong&gt; 源代码文件时，此文件通常被称为&lt;strong&gt;编译单元&lt;/strong&gt; (有时也被称为转译单元)。每个编译单元都必须有一个后缀名.java, 而在编译单元内则可以有一个 public 类，&lt;strong&gt;该类的名称必须与文件的名称相同&lt;/strong&gt; (包括大小写，但不包括文件的后缀名.java)。&lt;strong&gt;每个编译单元只能有一一个 public 类，否则编译器就不会接受&lt;/strong&gt;。如果在该编译单元之中还有额外的类的话，那么在包之外&lt;br&gt;
的世界是无法看见这些类的，这是因为它们不是 public 类，而且它们主要用来为主 publice 类提供&lt;br&gt;
支持。&lt;/p&gt;
&lt;p&gt;比如在 test 包下的 test.java 文件（编译单元）里面只能有一个和文件名称相同的 public 类也就是里面的 test 类 Person 类就不能加 public 限定符了。&lt;br&gt;
&lt;img src= &#34;/img/loading.gif&#34; data-lazy-src=&#34;https://img-blog.csdnimg.cn/20200808222558691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3OTE3OA==,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;br&gt;
同一个 test 包名下的类 test02 可以调用 Person 类&lt;br&gt;
&lt;img src= &#34;/img/loading.gif&#34; data-lazy-src=&#34;https://img-blog.csdnimg.cn/20200808222645339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3OTE3OA==,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;br&gt;
在另一个 test03 包名下的类 test03 就不能调用 Person 类了即使导入了包也不能，因为它不是 public 类型的&lt;br&gt;
&lt;img src= &#34;/img/loading.gif&#34; data-lazy-src=&#34;https://img-blog.csdnimg.cn/20200808222651248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3OTE3OA==,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-java访问权限修饰词&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#3-java访问权限修饰词&#34;&gt;#&lt;/a&gt; 3、Java 访问权限修饰词&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;public：接口访问权限（无论是谁，无论在哪都可以访问）&lt;br&gt;
使用关键字 public，就意味着 public 之后紧跟着的成员声明自己对每个人都是有用的，尤其是使用类库的客户程序员更是如此。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;protected：继承访问权限（子类可以访问父类的 public 成员和 protected 成员，但不可以访问父类的 private 成员）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（缺省）：包访问权限（类内部和同一个包里面的类可以访问（缺省）成员）&lt;br&gt;
因为（缺省）没有修饰词，形式如 int age ，也就是前面没有任何修饰词&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;private: 你无法访问（除了包含该类成员的类之外，其他任何类都无法访问这个成员）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了方便理解和比较准备了以下两张图片&lt;br&gt;
&lt;img src= &#34;/img/loading.gif&#34; data-lazy-src=&#34;https://img-blog.csdnimg.cn/20200808223740311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3OTE3OA==,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;br&gt;
&lt;img src= &#34;/img/loading.gif&#34; data-lazy-src=&#34;https://img-blog.csdnimg.cn/20200808223806321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3OTE3OA==,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
</content>
        <category term="java" />
        <category term="类" />
        <category term="面向对象" />
        <category term="访问权限" />
        <updated>2020-08-25T13:03:42.975Z</updated>
    </entry>
    <entry>
        <id>http://yoursite.com/2020/08/21/Java%E5%AD%A6%E4%B9%A0-%E7%B1%BB%E7%9A%84%E9%9A%90%E8%97%8F%E6%9C%BA%E5%88%B6(%E5%B0%81%E8%A3%85%E6%80%A7)/</id>
        <title>Java学习-类的隐藏机制（封装性）</title>
        <link rel="alternate" href="http://yoursite.com/2020/08/21/Java%E5%AD%A6%E4%B9%A0-%E7%B1%BB%E7%9A%84%E9%9A%90%E8%97%8F%E6%9C%BA%E5%88%B6(%E5%B0%81%E8%A3%85%E6%80%A7)/"/>
        <content type="html">&lt;h1 id=&#34;1-封装的含义&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#1-封装的含义&#34;&gt;#&lt;/a&gt; 1、封装的含义&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;封装&lt;/strong&gt;（encapsulation）是面向对象的三要素之一（其它两个是&lt;strong&gt;继承&lt;/strong&gt;和&lt;strong&gt;多态&lt;/strong&gt;），它有两成含义：&lt;br&gt;
1、将数据（属性）和函数（行为）放在一个独立的类中，使类成为一个独立的单元。&lt;br&gt;
2、通过访问限定符（private 等）实现对&lt;strong&gt;信息的隐藏或公开&lt;/strong&gt;，隐藏类的内部实现。而留下一些接口（public 的成员函数）与外界进行信息交换（外界要想访问某个成员只能通过接口实现）当类的设计者改变了类的内部实现时，但只要接口不变，对于类的使用者而言，没有任何影响。这就是所谓的 “&lt;strong&gt;接口和实现的分离&lt;/strong&gt;”&lt;br&gt;
&lt;strong&gt; 那么什么是封装？&lt;/strong&gt; 简单地说，封装就是将数据和函数放在一起，将不想让外界看到的内容（通常是数据）声明为 private 的，不允许外界存取。外界要想访问的话，就只能通过类留给外部的接口。&lt;br&gt;
&lt;strong&gt;为了更好的理解为什么要对对象进行封装，下面举个例子进行说明&lt;/strong&gt;&lt;br&gt;
先写两个类  ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Person 类&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;package day01&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;public &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;Person&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	public int age;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	public &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; printAge()&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;		System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;年龄是：&amp;quot;&lt;/span&gt;+age);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Test 测试类&lt;/li&gt;
&lt;/ul&gt;
 &lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;package day01&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;public &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;Test&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	 public &lt;span class=&#34;keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; main(&lt;span class=&#34;built_in&#34;&gt;String&lt;/span&gt;[] args)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	 	Person p = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; Person();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	 	p.age = &lt;span class=&#34;number&#34;&gt;-100&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	 	p.printAge();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	 &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行后打印结果为：年龄是：-100&lt;br&gt;
&lt;strong&gt; 分析一下代码：&lt;/strong&gt;&lt;br&gt;
程序是没问题的也能正常运行，但是年龄为 - 100 显然不符合正常逻辑。从代码可以看出在 new 完一个 person 对象后用户可以对它的 age 属性随便赋值。像这种情况是把类的属性开放出来，让调用者随意使用，这样就会出现问题，它们很容易被一些粗心的或不知情的客户端程序员所毁坏。&lt;br&gt;
所以我们需要对这样不能让调用者随意使用的属性做封装和隐藏以减少程序的 bug。这意味着类的创建者可以任意修改被隐藏的部分，而不用担心对其他调用者造成影响。&lt;br&gt;
代码修改后如下：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;package day01&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;public &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;Person&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	private int age;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	public &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; setAge(int a)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;		&lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt;(a &amp;lt;=&lt;span class=&#34;number&#34;&gt;150&lt;/span&gt; &amp;amp;&amp;amp; a&amp;gt;=&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;			&lt;span class=&#34;built_in&#34;&gt;this&lt;/span&gt;.age = a;	&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;		&amp;#125;&lt;span class=&#34;keyword&#34;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;			System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;输入的年龄：&amp;quot;&lt;/span&gt;+a+&lt;span class=&#34;string&#34;&gt;&amp;quot;不在0到150之间&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	public int getAge()&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&amp;#123; &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;this&lt;/span&gt;.age;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	public &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; showAge()&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;		System.out.println(&lt;span class=&#34;string&#34;&gt;&amp;quot;年龄是：&amp;quot;&lt;/span&gt;+&lt;span class=&#34;built_in&#34;&gt;this&lt;/span&gt;.getAge());&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;package day01&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;public &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;Test&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	 public &lt;span class=&#34;keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; main(&lt;span class=&#34;built_in&#34;&gt;String&lt;/span&gt;[] args)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	 	Person p1 = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; Person();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	 	Person p2 = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; Person();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	 	p1.setAge(&lt;span class=&#34;number&#34;&gt;55&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	 	p1.showAge();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	 	p2.setAge(&lt;span class=&#34;number&#34;&gt;60&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	 	p2.showAge();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	 &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到修改过后的对象不能直接通过 p.age 进行赋值操作，因为此时的 age 属性已经是被 private 限制，只能由类内部的成员函数调用并进行传参。&lt;/p&gt;
&lt;h1 id=&#34;2-类的setxxx-和-getxxx&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#2-类的setxxx-和-getxxx&#34;&gt;#&lt;/a&gt; 2、类的 setXXX 和 getXXX&lt;/h1&gt;
&lt;p&gt;封装的一个原则是：“信息的最小化公开”, 所以在理想状态下，通常将所有的数据都声明为 private（因为随便对类的内部数据进行更改是很危险的），如果想改变和得到某个数据的话，那么使用相应的接口进行访问&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通常设置数据的接口命名为 setXXX（如 public void setAge () ）&lt;/li&gt;
&lt;li&gt;将得到数据的接口命名为 getXXX（如 public int getAge () ）&lt;br&gt;
&lt;strong&gt;? 考虑这样两个问题：&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;问题一：&lt;/strong&gt; 使用 Person 类来定义的两个对象 p1 和 p2, 那么 p1 和 p2 两个对象在内存中的存储状态是怎么样的呢？即数据成员和成员函数是否都存放在对象中呢？&lt;br&gt;
&lt;strong&gt;问题二：&lt;/strong&gt; p1 和 p2 调用相同的成员函数，为什么显示结果不一样？它们调用的是同一段代码吗？&lt;br&gt;
其实对象空间中仅存储数据成员，而类的成员函数代码不会存储在对象中，用一个类的不同的对象调用成员函数时，调用的是同一段函数代码。&lt;br&gt;
&lt;strong&gt;成员函数和普通函数的区别：&lt;/strong&gt;&lt;br&gt;
在编译器的角度来看，成员函数和普通函数是没有本质区别的，成员函数只不过是为了封装的需要，而在形式上放在类中。最主要的区别是：&lt;br&gt;
&lt;em&gt;成员函数暗自具备了一个从编译器传过来的指向类对象的 this（当前对象的引用），通过它成员函数就可以操作当前对象的数据成员。&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;Person p1 = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; Person();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;Person p2 = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; Person();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;p1.setAge(&lt;span class=&#34;number&#34;&gt;55&lt;/span&gt;);&lt;span class=&#34;comment&#34;&gt;//在这里this指向p1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;p2.setAge(&lt;span class=&#34;number&#34;&gt;60&lt;/span&gt;);&lt;span class=&#34;comment&#34;&gt;//在这里this指向p2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&#34;3-this关键字&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#3-this关键字&#34;&gt;#&lt;/a&gt; 3、this 关键字&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;在类的方法定义中使用的 this 关键字表示使用该方法对象的引用。&lt;/li&gt;
&lt;li&gt;当必须指出当前使用方法对象是谁时要使用 this&lt;/li&gt;
&lt;li&gt;this 可以看作是一个变量，它的值是当前对象的引用&lt;/li&gt;
&lt;li&gt;当处理方法中成员变量和局部变量重名时要用 this&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;4-总结&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#4-总结&#34;&gt;#&lt;/a&gt; 4、总结&lt;/h1&gt;
&lt;p&gt;java 中类的封装和隐藏就是：&lt;br&gt;
通过将类的成员数据声明为私有的（private），再提供公共的（public）方法：getXXX () 和 setXXX () 实现对该属性的操作。以实现以下目的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;隐藏一个类中不需要对外提供的实现细节&lt;/li&gt;
&lt;li&gt;使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作；&lt;/li&gt;
&lt;li&gt;便于修改，增强代码的可维护性&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="java" />
        <category term="类" />
        <category term="面向对象" />
        <updated>2020-08-21T09:53:22.569Z</updated>
    </entry>
</feed>
