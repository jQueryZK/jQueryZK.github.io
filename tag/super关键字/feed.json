{
    "version": "https://jsonfeed.org/version/1",
    "title": "jQueryZK Blog • All posts by \"super关键字\" tag",
    "description": "过去无法挽回，未来可以改变",
    "home_page_url": "https://jQueryZK.github.io",
    "items": [
        {
            "id": "https://jqueryzk.github.io/2020/08/25/Java%E5%AD%A6%E4%B9%A0-%E7%BB%A7%E6%89%BF%E3%80%81super%E5%85%B3%E9%94%AE%E5%AD%97/",
            "url": "https://jqueryzk.github.io/2020/08/25/Java%E5%AD%A6%E4%B9%A0-%E7%BB%A7%E6%89%BF%E3%80%81super%E5%85%B3%E9%94%AE%E5%AD%97/",
            "title": "Java学习-继承、super关键字",
            "date_published": "2020-08-25T13:03:31.408Z",
            "content_html": "<h1 id=\"1-引例\"><a class=\"markdownIt-Anchor\" href=\"#1-引例\">#</a> 1、引例</h1>\n<p>假如现在有四个类它们的成员属性分别为：</p>\n<ul>\n<li>学生类：姓名，性别，年龄，学校</li>\n<li>教师类：姓名，性别，年龄，学科</li>\n<li>工人类：姓名，性别，年龄，工种</li>\n<li>农民类：姓名，性别，年龄，收入</li>\n</ul>\n<p>对于上面的四个类我们在实际写代码的时候会发现，发我在<strong>重复性</strong>地写一些代码比如（姓名、性别、年龄）是这四个类<strong>共有</strong>的<strong>成员属性</strong>。这时候我们就可以建一个 person 类把（姓名，性别，年龄）作为它的成员属性，而上面四个类通过继承这个 person 类实现对共有的成员属性的调用以提高代码的复用性</p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200810094026212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3OTE3OA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"2-继承\"><a class=\"markdownIt-Anchor\" href=\"#2-继承\">#</a> 2、继承</h1>\n<h2 id=\"21-概述\"><a class=\"markdownIt-Anchor\" href=\"#21-概述\">#</a> 2.1 概述</h2>\n<p>继承是 java 面向对象编程技术的一块基石，因为它允许创建分等级层次的类。继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p>\n<ul>\n<li>\n<p>继承是面向对象思想的三大特性之一，使类与类之间产生特殊的关系，即 is-a 关系。</p>\n</li>\n<li>\n<p>继承是从已有类中派生出新的类，新的类能吸收已有类的属性和方法，并且能拓展新的属性和行为。</p>\n</li>\n<li>\n<p>在 Java 中使用 extends 关键字表示继承，语法表示为: class 子类 extends 父类 {}</p>\n</li>\n<li>\n<p>子类被称为派生类，父类又被称为超类。</p>\n</li>\n<li>\n<p>子类继承父类，表示子类是一种特殊的父类，子类拥有父类的非 private 属性和方法，并且子类可以拓展具有父类所没有的一些属性和方法。</p>\n</li>\n<li>\n<p>子类即使不扩展父类，也能维持拥有父类的操作。</p>\n</li>\n</ul>\n<h2 id=\"22优缺点\"><a class=\"markdownIt-Anchor\" href=\"#22优缺点\">#</a> 2.2 优缺点</h2>\n<p>继承的好处是：</p>\n<ul>\n<li>提高了代码的复用性</li>\n<li>提高了代码的维护性</li>\n<li>让类与类之间产生了关系，是多态的前提</li>\n</ul>\n<p>继承的缺点是：</p>\n<ul>\n<li>增加了耦合性（OOP 思想开发原则：高内聚，低耦合    耦合：类与类之间的关系  内聚：自身完成事情的能力）</li>\n</ul>\n<h2 id=\"23java继承的类型\"><a class=\"markdownIt-Anchor\" href=\"#23java继承的类型\">#</a> 2.3Java 继承的类型</h2>\n<ul>\n<li>Java 只支持单继承，不支持多重继承</li>\n</ul>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200810101811626.png#pic_center\" alt=\"在这里插入图片描述\"><br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200810102402866.png#pic_center\" alt=\"在这里插入图片描述\"><br>\n多重继承会存在安全隐患，因为当继承的多个类都存在相同的属性或方法体不同的方法，子类进行调用时，就会产生不知道该调用哪一个类中的方法的情况</p>\n<ul>\n<li>Java 支持继承体系</li>\n</ul>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200810102503260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3OTE3OA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"3-关键字\"><a class=\"markdownIt-Anchor\" href=\"#3-关键字\">#</a> 3、关键字</h1>\n<h2 id=\"31super关键字\"><a class=\"markdownIt-Anchor\" href=\"#31super关键字\">#</a> 3.1super 关键字</h2>\n<p><strong>我们可以通过 super 关键字来实现对父类成员的访问，用来引用当前对象的父类。</strong></p>\n<p>两种方法：</p>\n<p>1、用在子类的构造方法里（初始化用），主要是调用父类的默认构造方法，如果父类有不止一个构造方法，可以通过 super 指定具体的构造函数，比如 super (paras)；</p>\n<p>注意：super 表示当前类的父类，super () 调用的是父类默认的构造方法，即这样可以对父类进行初始化。如何没有对父类进行初始化，当子类调用父类的方法时，便会从逻辑上出现错误，因为没对父类初始化，父类的方法和属性便没有内存空间。</p>\n<p>2、用在子类里调用隐藏或重写的属性或行为，比如 super.onDestroy () 等等</p>\n<h2 id=\"32super与this关键字的区别\"><a class=\"markdownIt-Anchor\" href=\"#32super与this关键字的区别\">#</a> 3.2super 与 this 关键字的区别</h2>\n<ol>\n<li>super（参数）：调用基类中的某一个构造函数（应该为构造函数中的第一条语句）</li>\n<li>this（参数）：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句）</li>\n<li>super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super. 变量名 super. 成员函数据名（实参）</li>\n<li>this：它代表当前对象名（在程序中易产生二义性之处，应使用 this 来指明当前对象；如果函数的形参与类中的成员数据同名这时需用 this 来指明成员变量名）</li>\n<li>调用 super () 必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用 super ()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。</li>\n<li>super () 和 this () 类似，区别是，super () 从子类中调用父类的构造方法，this () 在同一类内调用其它方法。</li>\n<li>super () 和 this () 均需放在构造方法内第一行。</li>\n<li>尽管可以用 this 调用一个构造器，但却不能调用两个。</li>\n<li>this 和 super 不能同时出现在一个构造函数里面，因为 this 必然会调用其它的构造函数，其它的构造函数必然也会有 super 语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li>\n<li>this () 和 super () 都指的是对象，所以，均不可以在 static 环境中使用。包括：static 变量，static 方法，static 语句块。</li>\n<li>从本质上讲，this 是一个指向本对象的指针，然而 super 是一个 Java 关键字。</li>\n</ol>\n<h1 id=\"4-继承需要注意的几个问题\"><a class=\"markdownIt-Anchor\" href=\"#4-继承需要注意的几个问题\">#</a> 4、继承需要注意的几个问题</h1>\n<h2 id=\"41成员变量和方法\"><a class=\"markdownIt-Anchor\" href=\"#41成员变量和方法\">#</a> 4.1 成员变量和方法</h2>\n<p>1、子类只能继承父类的所有非私有的成员变量和方法。可以继承 public protected 修饰的成员，不可以继承 private 修饰的。<br>\n2、但是子类可以通过父类中提供的 public 的 setter 和 getter 方法进行间接的访问和操作 private 的属性<br>\n 3、对于子类可以继承父类中的成员变量和成员方法，如果子类中出现了和父类同名的成员变量和成员方法时，父类的成员变量会被隐藏，父类的成员方法会被覆盖。需要使用父类的成员变量和方法时，就需要使用 super 关键字来进行引用。           （隐藏是针对成员变量和静态方法，覆盖是针对普通方法。）</p>\n<p>4、当创建一个子类对象时，不仅会为该类的实例变量分配内存，也会为它从父类继承得到的所有实例变量分配内存，即使子类定义了与父类中同名的实例变量，也依然会为父类中定义的、被隐藏的变量分配内存。</p>\n<p>5、如果子类中的实例变量被私有了 ，其父类中的同名实例变量没有被私有，那么子类对象就无法直接调用该变量，但可以通过先将对象变量强制向上转型为父类型，在通过该对象引用变量来访问那个实例变量，就会得到的是父类中的那个实例变量。                                                                                                                                                                                          (补充：什么是向上转型和向下转型？)</p>\n<h2 id=\"42构造器\"><a class=\"markdownIt-Anchor\" href=\"#42构造器\">#</a> 4.2 构造器</h2>\n<p>1、子类不能继承获得父类的构造方法，但是可以通过 super 关键字来访问父类构造方法。</p>\n<p>2、在一个构造器中调用另一个重载构造器使用 this 调用完成，在子类构造器中调用父类构造器使用 super 调用来完成。</p>\n<p>3、super 和 this 的调用都必须是在第一句，否则会产生编译错误，this 和 super 只能存在一个。不能进行递归构造器调用，即多个构造器之间互相循环调用。</p>\n<p>4、如果父类有无参构造时，所有构造方法（包含任意有参构造）自动默认都会访问父类中的空参构造方法。（自带 super ();）</p>\n<p>5、因为继承的目的是子类获取和使用父类的属性和行为，所以子类初始化之前，一定要先完成父类数据的初始化。</p>\n<p>6、在 Java 中，每个类都会默认继承 Object 超类，所以每一个构造方法的第一条默认语句都是 super ()</p>\n<p>7、如果父类没有无参构造，反而有其他的有参构造方法时，子类继承父类后，子类必须显式的创建构造器，不论子类的构造器是否和父类构造器中参数类型是否一致，都必须在子类的构造器中显式的通过 super 关键字调用和父类构造器相应参数的构造方法，否则编译都通不过。</p>\n<p><strong>代码示例：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</span><br><span class=\"line\">     System.out.println(age);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Student</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">super</span>(age);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Student</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">super</span>(<span class=\"number\">10</span>); <span class=\"comment\">//必须调用父类的有参构造</span></span><br><span class=\"line\">     System.out.println(<span class=\"string\">&quot;子类可以创建其他类型构造器，但是必须显式的用super调用父类构造器&quot;</span>)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也可以使用 this 先调用子类中的构造方法，再间接调用父类中的有参构造方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtendTest1</span>  </span>&#123;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">new</span> Student();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</span><br><span class=\"line\">     System.out.println(<span class=\"string\">&quot;父类有参构造&quot;</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Student</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">super</span>(age);</span><br><span class=\"line\">     System.out.println(<span class=\"string\">&quot;子类有参构造&quot;</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Student</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>(<span class=\"number\">10</span>); <span class=\"comment\">//可以使用this先调用子类中的有参构造，从而间接调用父类中的有参构造</span></span><br><span class=\"line\">     System.out.println(<span class=\"string\">&quot;子类无参构造&quot;</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 this，执行顺序结果为：先调用了子类中无参构造，此无参构造会接着调用子类中的有参构造，又接着调用父类中的有参构造，此时首先执行完毕了父类有参构造，接着子类有参构造执行完毕，最后子类无参构造才执行完毕。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">父类有参构造</span><br><span class=\"line\">子类有参构造</span><br><span class=\"line\">子类无参构造</span><br></pre></td></tr></table></figure>\n<p>以下这种是错误的：（因为当父类中没有无参构造器时，父类中没有这种类型的构造方法）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Student</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">super</span>();</span><br><span class=\"line\"> &#125; <span class=\"comment\">//错误的，因为当父类中没有无参构造器时，父类中没有这种类型的构造方法</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Student</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">super</span>(age);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name ,<span class=\"keyword\">int</span> age)</span></span>&#123;</span><br><span class=\"line\">     System.out.println(name+age);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</span><br><span class=\"line\">     System.out.println(age);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以下这种正确：（因为当父类中没有无参构造器时，子类中的构造方法的类型在父类中有）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">//因为当父类中没有无参构造器时，子类中的构造方法的类型在父类中有</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Student</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">super</span>(age);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name ,<span class=\"keyword\">int</span> age)</span></span>&#123;</span><br><span class=\"line\">     System.out.println(name+age);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</span><br><span class=\"line\">     System.out.println(age);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//因为当父类中没有无参构造器时，子类中的构造方法的类型在父类中有</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Student</span><span class=\"params\">(String name ,<span class=\"keyword\">int</span> age)</span></span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">super</span>(name,age);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Student</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">super</span>(age);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name ,<span class=\"keyword\">int</span> age)</span></span>&#123;</span><br><span class=\"line\">     System.out.println(name+age);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span></span>&#123;</span><br><span class=\"line\">     System.out.println(age);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结论：当父类中没有无参构造器时，子类继承父类，子类中的构造器方法类型可以和父类中的构造器不同，但是必须每个构造器都显式的使用 super 关键字调用父类中的某个有参构造器，也可以使用 this 调用子类中的某个有参构造器，但这个有参构造器必须通过 super 访问父类中的有参构造器。</p>\n<h2 id=\"43继承的执行顺序问题\"><a class=\"markdownIt-Anchor\" href=\"#43继承的执行顺序问题\">#</a> 4.3 继承的执行顺序问题</h2>\n<p>1、继承体系中的构造器执行顺序：</p>\n<ul>\n<li>当调用子类构造器实例化子类对象时，父类构造器总是在子类构造器之前执行。</li>\n<li>创建任何对象总是从该类所在继承树最顶层类的构造器开始执行，然后依次向下执行，最后才执行本类的构造器。如果父类通过 this 调用了同类中的重载构造器，就会依次执行此父类的多个构造器。</li>\n</ul>\n<p>2、继承体系中的静态域执行顺序：</p>\n<ul>\n<li>\n<p>当调用子类构造器实例化子类对象时，父类优先于子类进行加载到内存，所以会先执行父类中的静态域</p>\n</li>\n<li>\n<p>从该类所在继承树最顶层类开始加载，并执行其静态域，依次向下执行，最后执行本类。</p>\n</li>\n<li>\n<p>静态域优先于 main 方法，优先于构造器执行</p>\n</li>\n</ul>\n<p>3、父类和子类中<strong>都有静态代码块和构造代码块</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test2_Extends</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;主类静态块&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Zi z = <span class=\"keyword\">new</span> Zi();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fu</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;静态代码块Fu&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;构造代码块Fu&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Fu</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;构造方法Fu&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Zi</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fu</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;静态代码块Zi&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;构造代码块Zi&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Zi</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;构造方法Zi&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">主类静态块</span><br><span class=\"line\">静态代码块Fu</span><br><span class=\"line\">静态代码块Zi</span><br><span class=\"line\">构造代码块Fu</span><br><span class=\"line\">构造方法Fu</span><br><span class=\"line\">构造代码块Zi</span><br><span class=\"line\">构造方法Zi</span><br></pre></td></tr></table></figure>\n<p>执行顺序分析：</p>\n<p>1、主类 Test2_Extends 先加载到内存，静态域优先于 main 方法执行，先输出了主类静态块，其中的 main 方法入栈执行，main 方法中创建了子类对象<br>\n 2、子类对象创建过程中，父类和子类都加载到内存中，并且 Fu.class 优先于 Zi.class 加载，父类中的静态域先执行后，再执行子类中的静态域，此时会第一个输出：静态代码块 Fu，第二个输出：静态代码块 Zi<br>\n3、创建对象时进入子类的构造器，因为 Java 是分层初始化的，所以会先初始化父类再初始化子类，子类构造器会自动默认先执行父类的构造器，因为构造代码块优先于构造方法执行，所以此时就会先执行父类的构造代码块后，再执行父类的构造方法。所以第三个输出：构造代码块 Fu，第四个输出：构造方法 Fu<br>\n4、Fu 类初始化结束后，子类初始化，第五个输出的是：构造代码块 Zi，第六个输出：构造方法 Zi</p>\n<h2 id=\"44继承破坏父类封装性问题\"><a class=\"markdownIt-Anchor\" href=\"#44继承破坏父类封装性问题\">#</a> 4.4 继承破坏父类封装性问题</h2>\n<p>1、继承严重破坏了父类的封装性，每个类都应该它内部信息和实现细节，而只暴露必要的方法给其它类使用。但在继承关系中，子类可以直接访问父类的成员变量（内部信息）和方法， 从而造成子类和父类的严重耦合。</p>\n<p>2、父类的实现细节对其子类不再透明，从而导致子类可以恶意篡改父类的方法</p>\n<p><strong>改进方法：</strong></p>\n<ul>\n<li>尽量隐藏父类的内部数据。</li>\n<li>尽量把父类的所有成员变量都设置成 private 访问类型，不要让子类直接访问父类的成员变量</li>\n<li>不要让子类随意访问、修改父类的方法</li>\n<li>父类中那些仅为辅助其他的工具方法，应该使用 private 修饰，让子类无法访问方法；</li>\n<li>如果父类中的方法需要被外部类调用，则必须以 public 修饰，但又不想让子类重写，就可以使用 final 修饰符。</li>\n<li>如果希望父类的某个方法被子类重写，但不希望被其他类自由访问，则可以使用 protected 来修饰方法。</li>\n<li>尽量不要在父类构造器中调用将要被子类重写的方法。</li>\n</ul>\n<p>查看下面例子说明在父类构造器中调用被子类重写的方法引发的错误：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> extend;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Base</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;父类构造器&quot;</span>);</span><br><span class=\"line\">        test();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span>           <span class=\"comment\">// ①号test()方法</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;将被子类重写的方法&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sub</span> <span class=\"keyword\">extends</span> <span class=\"title\">Base</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Sub</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;子类构造器&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name=<span class=\"string\">&quot;aa&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span>         <span class=\"comment\">// ②号test()方法</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;子类test&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;子类重写父类的方法，&quot;</span></span><br><span class=\"line\">            + <span class=\"string\">&quot;其name字符串长度&quot;</span> + name.length());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 下面代码会引发空指针异常</span></span><br><span class=\"line\">        Sub s = <span class=\"keyword\">new</span> Sub();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">父类构造器</span><br><span class=\"line\">子类test</span><br><span class=\"line\">Exception in thread <span class=\"string\">&quot;main&quot;</span> java.lang.NullPointerException</span><br></pre></td></tr></table></figure>\n<p><strong>分析：</strong><br>\n当创建 Sub 对象时，先执行其父类构造器，如果父类构造器调用了被子类重写覆盖的方法，就会调用被子类重写后的②号 test () 方法，子类的 test 方法调用了子类的实例变量 name，父类直接调用的子类的 test 方法，此时子类还未初始化，还未调用子类构造器，实例变量 name 还未被指定初始值，仍然为默认值 null，所以引发了空指针异常。</p>\n<h2 id=\"45何时适合用继承\"><a class=\"markdownIt-Anchor\" href=\"#45何时适合用继承\">#</a> 4.5 何时适合用继承</h2>\n<ul>\n<li>子类需要额外增加属性，而不仅仅是属性值的改变。</li>\n<li>子类需要增加自己独有的行为方式（包括增加新的方法或重写父类的方法）。</li>\n</ul>\n",
            "tags": [
                "java",
                "面向对象",
                "继承",
                "super关键字"
            ]
        }
    ]
}