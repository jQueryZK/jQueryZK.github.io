{
    "version": "https://jsonfeed.org/version/1",
    "title": "jQueryZK Blog • All posts by \"访问权限\" tag",
    "description": "过去无法挽回，未来可以改变",
    "home_page_url": "https://jqueryzk.gitee.io/zkblog",
    "items": [
        {
            "id": "https://jqueryzk.gitee.io/zkblog/2020/08/25/Java%E5%AD%A6%E4%B9%A0-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/",
            "url": "https://jqueryzk.gitee.io/zkblog/2020/08/25/Java%E5%AD%A6%E4%B9%A0-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/",
            "title": "Java学习-访问权限控制",
            "date_published": "2020-08-25T13:03:42.975Z",
            "content_html": "<h1 id=\"1-为什么要有访问权限控制\"><a class=\"markdownIt-Anchor\" href=\"#1-为什么要有访问权限控制\">#</a> 1、为什么要有访问权限控制？</h1>\n<p><strong>访问控制 (或隐藏具体实现) 与 “最初的实现并不恰当” 有关。</strong><br>\n所有优秀的作者，包括那些编写软件的程序员，都清楚其著作的某些部分直至重新创作的时候才变得完美，有时甚至要反复重写多次。如果你把一个代码段放到了某个位置，等过一会儿回头再看时，有可能会发现有更好的方式去实现相同的功能。这正是重构的原动力之一，重构即重写代码，以使得它更可读、更易理解，并因此而更具可维护性。但是，在这种修改和完善代码的愿望之下，也存在着巨大的压力。通常总是会有一些消费者 (客户端程序员) 需要你的代码在某些方面保持不变。因此你想改变代码，而他们却想让代码保持不变。由此而产生了在面向对象设计中需要考虑的一一个基本问题:“如何把变动的事物与保持不变的事物区分开来”。<br>\n这对<strong>类库 (library)</strong> 而言尤为重要。该类库的消费者必须依赖他所使用的那部分类库，并且能够知道如果类库出现了新版本，他们并不需要改写代码。从另一个方面来说，类库的开发者必须有权限进行修改和改进，并确保客户代码不会因为这些改动而受到影响。 这一目标可以通过约定来达到。例如，类库开发者必须同意在改动类库中的类时不得删除任何现有方法，因为那样会破坏客户端程序员的代码。但是，与之相反的情况会更加棘手。在有域 (即数据成员) 存在的情况下，类库开发者要怎样才能知道究竟都有哪些域已经被客户端程序员所调用了呢？这对于方法仅为类的实现的一部分，因此并不想让客户端程序员直接使用的情况来说同样如此。如果程序开发者想要移除旧的实现而要添加新的实现时，结果将会怎样呢？改动任何一个成员都有可能破坏客户端程序员的代码。于是类库开发者会手脚被缚，无法对任何事物进行改动。<br>\n为了解决这一问题，Java 提供了<strong>访问权限修饰词</strong>，以供类库开发人员向客户端程序员指明<br>\n哪些是可用的，哪些是不可用的。访向权限控制的等级，从最大权限到最小权限依次为:</p>\n<p><strong>public、protected、包访问权限 (没有关键词称为 &quot;缺省&quot;) 和 private</strong></p>\n<p>构件类库的概念以及对于谁有权取用该类库构件的控制问题都还是不完善的。其中仍旧存在着如何将构件捆绑到一个内聚的类库单元中的问题。对于这一点，Java 用<strong>关键字 package</strong> 加以控制，而访问权限修饰词会因类是存在于一个相同的包，还是存在于一个单独的包而受到影响。</p>\n<h1 id=\"2-包库单元\"><a class=\"markdownIt-Anchor\" href=\"#2-包库单元\">#</a> 2、包：库单元</h1>\n<p><strong>包内包含有一组类，它们在单一的名字空间之下被组织到一起。</strong></p>\n<pre><code>  例如，在Java的标准发布中有一个工具库，它被组织在java.util名字空间下。java.util中有一个叫做ArrayList的类，使用ArrayList的一种方式是用其全名java.util.ArrayList来指定。\n</code></pre>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">F</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        java.util.ArrayList list = <span class=\"keyword\">new</span> java.util.ArrayList();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就使得程序变得很冗长，因此可以转而用 import 关键字，如果想要导入单个的类，可以在 import 语句中命名该类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">F</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        ArrayList list = <span class=\"keyword\">new</span> java.util.ArrayList();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，就可以不用限定地使用 ArrayList 了。但是，这样做 java.util 中的其他类仍旧是都不可以使用的。要想导入其中的所有类，只需要使用 &quot;*&quot;</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*</span><br></pre></td></tr></table></figure>\n<p><strong>Java 常用的类库：</strong></p>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200808223508652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3OTE3OA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>\n<strong>注意：</strong><br>\n当编写一个 <strong>.Java</strong> 源代码文件时，此文件通常被称为<strong>编译单元</strong> (有时也被称为转译单元)。每个编译单元都必须有一个后缀名.java, 而在编译单元内则可以有一个 public 类，<strong>该类的名称必须与文件的名称相同</strong> (包括大小写，但不包括文件的后缀名.java)。<strong>每个编译单元只能有一一个 public 类，否则编译器就不会接受</strong>。如果在该编译单元之中还有额外的类的话，那么在包之外<br>\n的世界是无法看见这些类的，这是因为它们不是 public 类，而且它们主要用来为主 publice 类提供<br>\n支持。</p>\n<p>比如在 test 包下的 test.java 文件（编译单元）里面只能有一个和文件名称相同的 public 类也就是里面的 test 类 Person 类就不能加 public 限定符了。<br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200808222558691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3OTE3OA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>\n同一个 test 包名下的类 test02 可以调用 Person 类<br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200808222645339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3OTE3OA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>\n在另一个 test03 包名下的类 test03 就不能调用 Person 类了即使导入了包也不能，因为它不是 public 类型的<br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200808222651248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3OTE3OA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"3-java访问权限修饰词\"><a class=\"markdownIt-Anchor\" href=\"#3-java访问权限修饰词\">#</a> 3、Java 访问权限修饰词</h1>\n<ul>\n<li>\n<p>public：接口访问权限（无论是谁，无论在哪都可以访问）<br>\n使用关键字 public，就意味着 public 之后紧跟着的成员声明自己对每个人都是有用的，尤其是使用类库的客户程序员更是如此。</p>\n</li>\n<li>\n<p>protected：继承访问权限（子类可以访问父类的 public 成员和 protected 成员，但不可以访问父类的 private 成员）</p>\n</li>\n<li>\n<p>（缺省）：包访问权限（类内部和同一个包里面的类可以访问（缺省）成员）<br>\n因为（缺省）没有修饰词，形式如 int age ，也就是前面没有任何修饰词</p>\n</li>\n<li>\n<p>private: 你无法访问（除了包含该类成员的类之外，其他任何类都无法访问这个成员）</p>\n</li>\n</ul>\n<p>为了方便理解和比较准备了以下两张图片<br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200808223740311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3OTE3OA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200808223806321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3OTE3OA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n",
            "tags": [
                "java",
                "面向对象",
                "类",
                "访问权限"
            ]
        }
    ]
}