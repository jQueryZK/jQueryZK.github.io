{
    "version": "https://jsonfeed.org/version/1",
    "title": "jQueryZK Blog • All posts by \"空间复杂度\" tag",
    "description": "过去无法挽回，未来可以改变",
    "home_page_url": "https://jqueryzk.gitee.io/zkblog",
    "items": [
        {
            "id": "https://jqueryzk.gitee.io/zkblog/2020/09/06/%E7%AE%97%E6%B3%95%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89-%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/",
            "url": "https://jqueryzk.gitee.io/zkblog/2020/09/06/%E7%AE%97%E6%B3%95%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89-%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/",
            "title": "算法（Java实现）-算法的时间复杂度和空间复杂度",
            "date_published": "2020-09-06T06:07:12.485Z",
            "content_html": "<h1 id=\"1-时间复杂度\"><a class=\"markdownIt-Anchor\" href=\"#1-时间复杂度\">#</a> 1、时间复杂度</h1>\n<h2 id=\"11度量一个程序算法执行时间的两种方法\"><a class=\"markdownIt-Anchor\" href=\"#11度量一个程序算法执行时间的两种方法\">#</a> 1.1 度量一个程序（算法）执行时间的两种方法</h2>\n<p><strong>事后统计的方法</strong></p>\n<p>这种方法可行，但是有两个问题：<br>\n一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；<br>\n二是所得时间的统计量依赖于计算机的硬件、软件等环境因素，<strong>这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快</strong>。</p>\n<ul>\n<li><strong>事前估计的方法</strong></li>\n</ul>\n<p>通过分析某个<strong>算法的时间复杂度</strong>来判断哪个算法更优。因事后统计方法更多的依赖于计算机的硬件、软件等环境因素，有时容易掩盖算法本身的优劣。<strong>因此人们常常采用事前分析估算的方法。</strong></p>\n<p>在编写程序前，依据统计方法对算法进行估算。一个用高级语言编写的程序在计算机上运行时所消耗的时间取决于下列因素：</p>\n<ol>\n<li>算法采用的策略、方法；</li>\n<li>编译产生的代码质量；</li>\n<li>问题的输入规模；</li>\n<li>机器执行指令的速度。<br>\n一个算法是由<strong>控制结构</strong>（顺序、分支和循环 3 种）和<strong>原操作</strong>（指固有数据类型的操作）构成的，则<strong>算法时间取决于两者的综合效果</strong>。为了便于比较同一个问题的不同算法，通常的做法是，从算法中选取一种对于所研究的问题（或算法类型）来说是基本操作的原操作，以该基本操作的<strong>重复执行的次数作为算法的时间量度</strong>。</li>\n</ol>\n<h2 id=\"12时间频度\"><a class=\"markdownIt-Anchor\" href=\"#12时间频度\">#</a> 1.2 时间频度</h2>\n<p><strong>时间频度</strong>：一个算法花费的时间与算法中语句的执行次数成正比例，<strong>哪个算法中语句执行次数多，它花费时间就多</strong>。<font color=red>一个算法中的语句执行次数</font>称为语句频度或<strong>时间频度</strong>。记为<strong> T (n)</strong>。<br>\n举例：<br>\n<strong>比如计算 1-100 所有数字之和，我们设计两种算法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> total=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> end=<span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=end;i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\ttotal+=i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>T (n) = n+1；也就是要执行 101 次第 101 次也要判断一下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">total=（<span class=\"number\">1</span>+end）*end/<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>T (n)=1；也就是只需要执行一次</p>\n<p><strong>忽略常数项</strong>：<br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200903203501203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3OTE3OA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/2020090320350961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3OTE3OA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>\n观察图像分析：<br>\n2n+20 和 2n 随着 n 变大，执行曲线无限接近，20 可以忽略<br>\n 3n+10 和 3n 随着 n 变大，执行曲线无限接近，10 可以忽略<br>\n<strong>忽略低次项</strong>：<img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200903204245124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3OTE3OA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200903204310327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3OTE3OA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>\n观察图像分析：<br>\n2n^2+3n+10 和 2n^2 随着 n 变大，执行曲线无限接近，可以忽略 3n+10<br>\nn^2+5n+20 和 n^2 随着 n 变大，执行曲线无限接近，可以忽略 5n+20<br>\n<strong> 忽略系数</strong>：<br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200903204444910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3OTE3OA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200903204453554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3OTE3OA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>\n观察图像分析：<br>\n随着 n 值变大，5n^2+7n 和 3n^2 + 2n ，执行曲线重合，说明  这种情况下，5 和 3 可以忽略。<br>\n而 n^3+5n 和 6n^3+4n  ，执行曲线分离，说明多少次方才是关键</p>\n<h2 id=\"13时间复杂度\"><a class=\"markdownIt-Anchor\" href=\"#13时间复杂度\">#</a> 1.3 时间复杂度</h2>\n<p>一般情况下，算法中的基本操作语句的重复执行次数是问题规模 n 的某个函数，用 T (n) 表示，若有某个辅助函数 f (n)，使得当 n 趋近于无穷大时，T (n) /f (n) 的极限值为不等于零的常数，则称 f (n) 是 T (n) 的同数量级函数。<strong>记作 T (n)=Ｏ( f (n) )，称Ｏ( f (n) )  为算法的渐进时间复杂度，简称时间复杂度</strong>。</p>\n<p><strong>T (n) 不同，但时间复杂度可能相同</strong>。<br>\n如：T (n)=n²+7n+6 与 T (n)=3n²+2n+2 它们的 T (n) 不同，但时间复杂度相同，都为 O (n²)。</p>\n<p><strong>计算时间复杂度的方法</strong>：<br>\n比如：计算 T (n)=3n²+2n+2 的时间复杂度</p>\n<ol>\n<li>用常数 1 代替运行时间中的所有加法常数：  T (n)=3n²+2n+2  =&gt; T (n)=3n²+2n+1</li>\n<li>修改后的运行次数函数中，只保留最高阶项  T (n)=3n²+2n+1 =&gt; T (n) = 3n²</li>\n<li>去除最高阶项的系数 T (n) = 3n² =&gt; T (n) = n² =&gt; <strong>O(n²)</strong></li>\n</ol>\n<h2 id=\"14常见的时间复杂度\"><a class=\"markdownIt-Anchor\" href=\"#14常见的时间复杂度\">#</a> 1.4 常见的时间复杂度</h2>\n<p><img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200903211501685.png#\" alt=\"在这里插入图片描述\"><br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200906102546620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3OTE3OA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>\n常见的算法时间复杂度由小到大依次为：<br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200903211622396.png#\" alt=\"在这里插入图片描述\"><br>\n随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低。从图中可见，<strong>我们应该尽可能避免使用指数阶的算法</strong><br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200903212308811.png#\" alt=\"在这里插入图片描述\"><br>\n无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是 O (1)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> j = <span class=\"number\">2</span>;</span><br><span class=\"line\">++i;</span><br><span class=\"line\">j++;</span><br><span class=\"line\"><span class=\"keyword\">int</span> m = i + j;</span><br></pre></td></tr></table></figure>\n<p>上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用 O (1) 来表示它的时间复杂度。<br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200906100358901.png#pic_cent\" alt=\"在这里插入图片描述\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(i&lt;n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\ti=i*<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>说明：在 while 循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环 x 次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2n 也就是说当循环 log2n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O (log2^n)  。 O (log2^n) 的这个 2 时间上是根据代码变化的，i = i * 3 ，则是 O (log3^n) .<br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200906100705448.png#\" alt=\"在这里插入图片描述\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tj = i;</span><br><span class=\"line\">\tj++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>说明：这段代码，for 循环里面的代码会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化的，因此这类代码都可以用 O (n) 来表示它的时间复杂度<br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200906102006267.png#pic\" alt=\"在这里插入图片描述\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(m=<span class=\"number\">1</span>;m&lt;n;m++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(i&lt;n)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ti=i*<span class=\"number\">2</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>说明：线性<strong>对数阶 O (nlogN)</strong> 其实非常容易理解，将时间复杂度为 O (logn) 的代码循环 N 遍的话，那么它的时间复杂度就是 n * O (logN)，也就是了 O (nlogN)。比如上面的代码的时间复杂度就是 O (nlog2^ n) , 如果 i=i * 2 改为 i=i * 3 的话，时间复杂度就是 O (nlog3^ n)<br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200906103400793.png#pic_cent\" alt=\"在这里插入图片描述\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(x=<span class=\"number\">1</span>; i&lt;=n; x++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>; i&lt;=n; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tj = i;</span><br><span class=\"line\">\t\tj++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>说明：平方阶 O (n²) 就更容易理解了，如果把 O (n) 的代码再嵌套循环一遍，它的时间复杂度就是 O (n²)，这段代码其实就是嵌套了 2 层 n 循环，它的时间复杂度就是 O (n<em>n)，即  O (n²) 如果将其中一层循环的 n 改成 m，那它的时间复杂度就变成了 O (m</em>n)<br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/2020090613433984.png#pic_ce\" alt=\"在这里插入图片描述\"><br>\n O (n³) 相当于三层 n 循环<br>\n<img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200906134351820.png#pic_cent\" alt=\"在这里插入图片描述\"><br>\n O (n^k) 相当于 k 层循环</p>\n<h2 id=\"15平均时间复杂度和最坏时间复杂度\"><a class=\"markdownIt-Anchor\" href=\"#15平均时间复杂度和最坏时间复杂度\">#</a> 1.5 平均时间复杂度和最坏时间复杂度</h2>\n<ol>\n<li>平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。</li>\n<li>最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。</li>\n<li>平均时间复杂度和最坏时间复杂度是否一致，和算法有关。</li>\n</ol>\n<p>比如下图为八大排序算法的时间复杂度：<img src= \"/img/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200906134845435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI3OTE3OA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"2-算法的空间复杂度\"><a class=\"markdownIt-Anchor\" href=\"#2-算法的空间复杂度\">#</a> 2、算法的空间复杂度</h1>\n<ul>\n<li>类似于时间复杂度的讨论，一个算法的空间复杂度 (Space Complexity) 定义为该算法所耗费的存储空间，它也是问题规模 n 的函数。</li>\n<li>空间复杂度 (Space Complexity) 是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模 n 有关，它随着 n 的增大而增大，当 n 较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况</li>\n<li>在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品 (redis,memcache) 和算法 (基数排序) 本质就是用空间换时间.</li>\n</ul>\n",
            "tags": [
                "算法",
                "时间复杂度",
                "空间复杂度"
            ]
        }
    ]
}